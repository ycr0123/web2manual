---
title: "Hooks reference"
titleKo: "훅 레퍼런스"
description: "Reference for Claude Code hook events, configuration schema, JSON input/output formats, and exit codes."
descriptionKo: "Claude Code 훅 이벤트, 설정 스키마, JSON 입출력 형식에 대한 레퍼런스입니다."
source: https://code.claude.com/docs/en/hooks.md
fetched: 2026-02-18
section: 6.11
---

# 훅 레퍼런스

> Claude Code 훅 이벤트, 설정 스키마, JSON 입출력 형식, 종료 코드, 비동기 훅, 프롬프트 훅, MCP 도구 훅에 대한 레퍼런스입니다.

> 예시가 포함된 빠른 시작 가이드는 훅으로 워크플로우 자동화를 참조하세요.

Hooks는 Claude Code의 라이프사이클의 특정 지점에서 자동으로 실행되는 사용자 정의 셸 명령 또는 LLM 프롬프트입니다. 이 레퍼런스를 사용하여 이벤트 스키마, 구성 옵션, JSON 입출력 형식, 비동기 hooks 및 MCP 도구 hooks와 같은 고급 기능을 확인하세요.

## Hook 라이프사이클

Hooks는 Claude Code 세션의 특정 지점에서 발동합니다. 아래 표는 각 이벤트가 발동하는 시점을 요약합니다:

| 이벤트 | 발동 시점 |
| :--- | :--- |
| `SessionStart` | 세션이 시작되거나 재개될 때 |
| `UserPromptSubmit` | 프롬프트를 제출할 때, Claude가 처리하기 전 |
| `PreToolUse` | 도구 호출이 실행되기 전. 차단할 수 있음 |
| `PermissionRequest` | 권한 대화상자가 나타날 때 |
| `PostToolUse` | 도구 호출이 성공한 후 |
| `PostToolUseFailure` | 도구 호출이 실패한 후 |
| `Notification` | Claude Code가 알림을 전송할 때 |
| `SubagentStart` | 서브에이전트가 생성될 때 |
| `SubagentStop` | 서브에이전트가 완료될 때 |
| `Stop` | Claude가 응답을 완료할 때 |
| `TeammateIdle` | 에이전트 팀 팀원이 유휴 상태가 되려 할 때 |
| `TaskCompleted` | 작업이 완료로 표시될 때 |
| `PreCompact` | 컨텍스트 압축 전 |
| `SessionEnd` | 세션이 종료될 때 |

### Hook의 해결 방법

파괴적인 셸 명령을 차단하는 이 `PreToolUse` hook을 생각해 보세요:

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": ".claude/hooks/block-rm.sh"
          }
        ]
      }
    ]
  }
}
```

스크립트는 stdin에서 JSON 입력을 읽고 `rm -rf`가 포함된 경우 `permissionDecision`을 `"deny"`로 반환합니다:

```bash
#!/bin/bash
# .claude/hooks/block-rm.sh
COMMAND=$(jq -r '.tool_input.command')

if echo "$COMMAND" | grep -q 'rm -rf'; then
  jq -n '{
    hookSpecificOutput: {
      hookEventName: "PreToolUse",
      permissionDecision: "deny",
      permissionDecisionReason: "Destructive command blocked by hook"
    }
  }'
else
  exit 0  # 명령 허용
fi
```

Claude Code가 `Bash "rm -rf /tmp/build"`를 실행하기로 결정하면:

1. **이벤트 발동**: Claude Code가 도구 입력을 stdin의 JSON으로 전송
2. **매처 확인**: 매처 `"Bash"`가 도구 이름과 일치
3. **Hook 핸들러 실행**: 스크립트가 명령을 차단하고 결정을 인쇄
4. **Claude Code 동작**: Claude Code가 JSON 결정을 읽고 도구 호출을 차단하며 Claude에게 이유를 표시

## 구성

Hooks는 JSON 설정 파일에 정의됩니다. 구성에는 세 가지 중첩 수준이 있습니다:

1. 응답할 hook 이벤트를 선택합니다 (예: `PreToolUse` 또는 `Stop`)
2. 발동 시기를 필터링하는 매처 그룹을 추가합니다
3. 일치할 때 실행할 하나 이상의 hook 핸들러를 정의합니다

### Hook 위치

| 위치 | 범위 | 공유 가능 |
| :--- | :--- | :--- |
| `~/.claude/settings.json` | 모든 프로젝트 | 아니요, 머신 로컬 |
| `.claude/settings.json` | 단일 프로젝트 | 예, 저장소에 커밋 가능 |
| `.claude/settings.local.json` | 단일 프로젝트 | 아니요, gitignore됨 |
| Managed 정책 설정 | 조직 전체 | 예, 관리자가 제어 |
| 플러그인 `hooks/hooks.json` | 플러그인이 활성화된 경우 | 예, 플러그인과 번들됨 |
| 스킬 또는 에이전트 frontmatter | 컴포넌트가 활성화된 동안 | 예, 컴포넌트 파일에 정의됨 |

### 매처 패턴

`matcher` 필드는 hooks가 발동하는 시기를 필터링하는 regex 문자열입니다. `"*"`, `""` 또는 `matcher`를 완전히 생략하면 모든 발생과 일치합니다.

| 이벤트 | 매처가 필터링하는 것 | 예시 매처 값 |
| :--- | :--- | :--- |
| `PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `PermissionRequest` | 도구 이름 | `Bash`, `Edit\|Write`, `mcp__.*` |
| `SessionStart` | 세션이 시작된 방법 | `startup`, `resume`, `clear`, `compact` |
| `SessionEnd` | 세션이 종료된 이유 | `clear`, `logout`, `prompt_input_exit`, `bypass_permissions_disabled`, `other` |
| `Notification` | 알림 유형 | `permission_prompt`, `idle_prompt`, `auth_success`, `elicitation_dialog` |
| `SubagentStart` | 에이전트 유형 | `Bash`, `Explore`, `Plan` 또는 커스텀 에이전트 이름 |
| `PreCompact` | 압축을 트리거한 것 | `manual`, `auto` |
| `SubagentStop` | 에이전트 유형 | `SubagentStart`와 동일한 값 |
| `UserPromptSubmit`, `Stop`, `TeammateIdle`, `TaskCompleted` | 매처 지원 없음 | 모든 발생 시마다 항상 발동 |

예시 - Claude가 파일을 쓰거나 편집할 때만 린팅 스크립트 실행:

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "/path/to/lint-check.sh"
          }
        ]
      }
    ]
  }
}
```

#### MCP 도구 매칭

MCP 도구는 `mcp__<server>__<tool>` 명명 패턴을 따릅니다. 예:

* `mcp__memory__create_entities`: Memory 서버의 create entities 도구
* `mcp__filesystem__read_file`: Filesystem 서버의 read file 도구
* `mcp__github__search_repositories`: GitHub 서버의 search 도구

특정 MCP 도구나 그룹을 대상으로 하는 regex 패턴을 사용합니다:

* `mcp__memory__.*` - `memory` 서버의 모든 도구와 일치
* `mcp__.*__write.*` - 모든 서버에서 "write"가 포함된 모든 도구와 일치

### Hook 핸들러 필드

내부 `hooks` 배열의 각 객체는 hook 핸들러입니다. 세 가지 유형이 있습니다:

* **Command hooks** (`type: "command"`): 셸 명령 실행
* **Prompt hooks** (`type: "prompt"`): 단일 턴 평가를 위해 Claude 모델에 프롬프트 전송
* **Agent hooks** (`type: "agent"`): 조건을 검증하기 위해 도구를 사용할 수 있는 서브에이전트 생성

#### 공통 필드

| 필드 | 필수 | 설명 |
| :--- | :--- | :--- |
| `type` | 예 | `"command"`, `"prompt"`, 또는 `"agent"` |
| `timeout` | 아니요 | 취소하기 전 초. 기본값: command는 600, prompt는 30, agent는 60 |
| `statusMessage` | 아니요 | hook 실행 중 표시되는 커스텀 스피너 메시지 |
| `once` | 아니요 | `true`인 경우, 세션당 한 번만 실행한 다음 제거됩니다. 에이전트가 아닌 스킬만 해당. |

#### Command hook 필드

| 필드 | 필수 | 설명 |
| :--- | :--- | :--- |
| `command` | 예 | 실행할 셸 명령 |
| `async` | 아니요 | `true`인 경우, 차단하지 않고 백그라운드에서 실행 |

#### Prompt 및 agent hook 필드

| 필드 | 필수 | 설명 |
| :--- | :--- | :--- |
| `prompt` | 예 | 모델에 전송할 프롬프트 텍스트. hook 입력 JSON의 플레이스홀더로 `$ARGUMENTS` 사용 |
| `model` | 아니요 | 평가에 사용할 모델. 기본값은 빠른 모델 |

### 경로로 스크립트 참조

hook 스크립트를 참조하기 위해 환경 변수를 사용합니다:

* `$CLAUDE_PROJECT_DIR`: 프로젝트 루트
* `${CLAUDE_PLUGIN_ROOT}`: 플러그인의 루트 디렉토리

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/check-style.sh"
          }
        ]
      }
    ]
  }
}
```

**플러그인 hooks** - 선택적 최상위 `description` 필드를 사용하여 `hooks/hooks.json`에 플러그인 hooks를 정의합니다:

```json
{
  "description": "Automatic code formatting",
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "${CLAUDE_PLUGIN_ROOT}/scripts/format.sh",
            "timeout": 30
          }
        ]
      }
    ]
  }
}
```

### 스킬 및 에이전트의 Hooks

Hooks는 frontmatter를 사용하여 스킬 및 서브에이전트에 직접 정의될 수 있습니다. 이러한 hooks는 컴포넌트의 라이프사이클에 범위가 지정되며 해당 컴포넌트가 활성화되어 있을 때만 실행됩니다.

```yaml
---
name: secure-operations
description: Perform operations with security checks
hooks:
  PreToolUse:
    - matcher: "Bash"
      hooks:
        - type: command
          command: "./scripts/security-check.sh"
---
```

### `/hooks` 메뉴

Claude Code에서 `/hooks`를 입력하면 설정 파일을 직접 편집하지 않고도 hooks를 보고 추가하고 삭제할 수 있는 대화형 hooks 관리자가 열립니다.

메뉴의 각 hook에는 소스를 나타내는 대괄호 접두사가 표시됩니다:

* `[User]`: `~/.claude/settings.json`에서
* `[Project]`: `.claude/settings.json`에서
* `[Local]`: `.claude/settings.local.json`에서
* `[Plugin]`: 플러그인의 `hooks/hooks.json`에서, 읽기 전용

### Hooks 비활성화 또는 제거

설정 파일에서 `"disableAllHooks": true`를 설정하거나 `/hooks` 메뉴에서 토글을 사용하면 hooks를 제거하지 않고 일시적으로 비활성화할 수 있습니다.

설정 파일의 hooks를 직접 편집해도 즉시 적용되지 않습니다. Claude Code는 시작 시 hooks의 스냅샷을 캡처합니다. hooks가 외부에서 수정되면 Claude Code가 경고를 표시하고 변경 사항이 적용되기 전에 `/hooks` 메뉴에서 검토가 필요합니다.

## Hook 입력 및 출력

### 공통 입력 필드

모든 hook 이벤트는 stdin을 통해 JSON으로 다음 필드를 받습니다:

| 필드 | 설명 |
| :--- | :--- |
| `session_id` | 현재 세션 식별자 |
| `transcript_path` | 대화 JSON 경로 |
| `cwd` | hook이 호출될 때의 현재 작업 디렉토리 |
| `permission_mode` | 현재 권한 모드 |
| `hook_event_name` | 발동한 이벤트 이름 |

예를 들어, Bash 명령에 대한 `PreToolUse` hook은 stdin에서 다음을 받습니다:

```json
{
  "session_id": "abc123",
  "transcript_path": "/home/user/.claude/projects/.../transcript.jsonl",
  "cwd": "/home/user/my-project",
  "permission_mode": "default",
  "hook_event_name": "PreToolUse",
  "tool_name": "Bash",
  "tool_input": {
    "command": "npm test"
  }
}
```

### 종료 코드 출력

**Exit 0**은 성공을 의미합니다. Claude Code는 JSON 출력 필드를 위해 stdout을 파싱합니다.

**Exit 2**는 차단 오류를 의미합니다. Claude Code는 stdout을 무시합니다. stderr 텍스트가 오류 메시지로 Claude에게 피드백됩니다.

**다른 종료 코드**는 비차단 오류입니다. stderr는 상세 모드에서 표시됩니다.

#### 이벤트별 Exit 코드 2 동작

| Hook 이벤트 | 차단 가능? | Exit 2 시 발생하는 일 |
| :--- | :--- | :--- |
| `PreToolUse` | 예 | 도구 호출 차단 |
| `PermissionRequest` | 예 | 권한 거부 |
| `UserPromptSubmit` | 예 | 프롬프트 처리 차단 및 프롬프트 삭제 |
| `Stop` | 예 | Claude가 중단하지 못하도록 방지, 대화 계속 |
| `SubagentStop` | 예 | 서브에이전트가 중단하지 못하도록 방지 |
| `TeammateIdle` | 예 | 팀원이 유휴 상태가 되지 못하도록 방지 |
| `TaskCompleted` | 예 | 작업이 완료로 표시되지 못하도록 방지 |
| `PostToolUse` | 아니요 | stderr를 Claude에게 표시 (도구가 이미 실행됨) |
| `PostToolUseFailure` | 아니요 | stderr를 Claude에게 표시 (도구가 이미 실패함) |
| `Notification` | 아니요 | stderr를 사용자에게만 표시 |
| `SubagentStart` | 아니요 | stderr를 사용자에게만 표시 |
| `SessionStart` | 아니요 | stderr를 사용자에게만 표시 |
| `SessionEnd` | 아니요 | stderr를 사용자에게만 표시 |
| `PreCompact` | 아니요 | stderr를 사용자에게만 표시 |

### JSON 출력

더 많은 제어를 위해 exit 0으로 종료하고 stdout에 JSON 객체를 인쇄합니다:

> hook당 하나의 접근 방식을 선택해야 합니다: 신호를 위해 종료 코드만 사용하거나, 구조화된 제어를 위해 exit 0과 JSON 인쇄 중 하나를 선택하세요.

범용 필드:

| 필드 | 기본값 | 설명 |
| :--- | :--- | :--- |
| `continue` | `true` | `false`이면 hook 실행 후 Claude가 처리를 완전히 중단합니다 |
| `stopReason` | 없음 | `continue`가 `false`인 경우 사용자에게 표시되는 메시지 |
| `suppressOutput` | `false` | `true`이면 상세 모드 출력에서 stdout을 숨깁니다 |
| `systemMessage` | 없음 | 사용자에게 표시되는 경고 메시지 |

Claude를 완전히 중단하려면:

```json
{ "continue": false, "stopReason": "Build failed, fix errors before continuing" }
```

#### 결정 제어

| 이벤트 | 결정 패턴 | 핵심 필드 |
| :--- | :--- | :--- |
| UserPromptSubmit, PostToolUse, PostToolUseFailure, Stop, SubagentStop | 최상위 `decision` | `decision: "block"`, `reason` |
| TeammateIdle, TaskCompleted | 종료 코드만 | Exit 코드 2가 동작을 차단 |
| PreToolUse | `hookSpecificOutput` | `permissionDecision` (allow/deny/ask), `permissionDecisionReason` |
| PermissionRequest | `hookSpecificOutput` | `decision.behavior` (allow/deny) |

**최상위 decision** (UserPromptSubmit, PostToolUse, PostToolUseFailure, Stop, SubagentStop에서 사용):

```json
{
  "decision": "block",
  "reason": "Test suite must pass before proceeding"
}
```

**PreToolUse**:

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "deny",
    "permissionDecisionReason": "Database writes are not allowed"
  }
}
```

**PermissionRequest**:

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PermissionRequest",
    "decision": {
      "behavior": "allow",
      "updatedInput": {
        "command": "npm run lint"
      }
    }
  }
}
```

## Hook 이벤트

### SessionStart

Claude Code가 새 세션을 시작하거나 기존 세션을 재개할 때 실행됩니다.

매처 값은 세션이 시작된 방법에 해당합니다:

| 매처 | 발동 시점 |
| :--- | :--- |
| `startup` | 새 세션 |
| `resume` | `--resume`, `--continue`, 또는 `/resume` |
| `clear` | `/clear` |
| `compact` | 자동 또는 수동 압축 |

#### SessionStart 입력

공통 입력 필드 외에도 SessionStart hooks는 `source`, `model`, 그리고 선택적으로 `agent_type`을 받습니다.

```json
{
  "session_id": "abc123",
  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",
  "cwd": "/Users/...",
  "permission_mode": "default",
  "hook_event_name": "SessionStart",
  "source": "startup",
  "model": "claude-sonnet-4-6"
}
```

#### SessionStart 결정 제어

hook 스크립트가 stdout에 인쇄하는 텍스트는 Claude의 컨텍스트로 추가됩니다. 반환할 수 있는 내용:

| 필드 | 설명 |
| :--- | :--- |
| `additionalContext` | Claude의 컨텍스트에 추가된 문자열 |

#### 환경 변수 지속

SessionStart hooks는 `CLAUDE_ENV_FILE` 환경 변수에 접근할 수 있습니다:

```bash
#!/bin/bash

if [ -n "$CLAUDE_ENV_FILE" ]; then
  echo 'export NODE_ENV=production' >> "$CLAUDE_ENV_FILE"
  echo 'export DEBUG_LOG=true' >> "$CLAUDE_ENV_FILE"
fi

exit 0
```

### UserPromptSubmit

사용자가 프롬프트를 제출할 때, Claude가 처리하기 전에 실행됩니다.

#### UserPromptSubmit 입력

공통 입력 필드 외에도 UserPromptSubmit hooks는 `prompt` 필드를 받습니다:

```json
{
  "session_id": "abc123",
  "hook_event_name": "UserPromptSubmit",
  "prompt": "Write a function to calculate the factorial of a number"
}
```

#### UserPromptSubmit 결정 제어

| 필드 | 설명 |
| :--- | :--- |
| `decision` | `"block"`이면 프롬프트가 처리되지 않도록 방지 |
| `reason` | `decision`이 `"block"`인 경우 사용자에게 표시 |
| `additionalContext` | Claude의 컨텍스트에 추가된 문자열 |

```json
{
  "decision": "block",
  "reason": "Explanation for decision",
  "hookSpecificOutput": {
    "hookEventName": "UserPromptSubmit",
    "additionalContext": "My additional context here"
  }
}
```

### PreToolUse

Claude가 도구 파라미터를 만든 후 도구 호출을 처리하기 전에 실행됩니다. 도구 이름에서 매칭됩니다: `Bash`, `Edit`, `Write`, `Read`, `Glob`, `Grep`, `Task`, `WebFetch`, `WebSearch`, 그리고 모든 MCP 도구 이름.

#### PreToolUse 입력 - Bash

| 필드 | 유형 | 예시 | 설명 |
| :--- | :--- | :--- | :--- |
| `command` | string | `"npm test"` | 실행할 셸 명령 |
| `description` | string | `"Run test suite"` | 선택적 설명 |
| `timeout` | number | `120000` | 선택적 타임아웃 (밀리초) |
| `run_in_background` | boolean | `false` | 백그라운드에서 실행할지 여부 |

#### PreToolUse 입력 - Write

| 필드 | 유형 | 예시 | 설명 |
| :--- | :--- | :--- | :--- |
| `file_path` | string | `"/path/to/file.txt"` | 쓸 파일의 절대 경로 |
| `content` | string | `"file content"` | 파일에 쓸 내용 |

#### PreToolUse 입력 - Edit

| 필드 | 유형 | 예시 | 설명 |
| :--- | :--- | :--- | :--- |
| `file_path` | string | `"/path/to/file.txt"` | 편집할 파일의 절대 경로 |
| `old_string` | string | `"original text"` | 찾아 대체할 텍스트 |
| `new_string` | string | `"replacement text"` | 대체 텍스트 |
| `replace_all` | boolean | `false` | 모든 발생을 대체할지 여부 |

#### PreToolUse 입력 - Read

| 필드 | 유형 | 예시 | 설명 |
| :--- | :--- | :--- | :--- |
| `file_path` | string | `"/path/to/file.txt"` | 읽을 파일의 절대 경로 |
| `offset` | number | `10` | 선택적 읽기 시작 줄 번호 |
| `limit` | number | `50` | 선택적 읽을 줄 수 |

#### PreToolUse 입력 - Glob

| 필드 | 유형 | 예시 | 설명 |
| :--- | :--- | :--- | :--- |
| `pattern` | string | `"**/*.ts"` | 파일과 매칭할 Glob 패턴 |
| `path` | string | `"/path/to/dir"` | 선택적 검색할 디렉토리 |

#### PreToolUse 입력 - Grep

| 필드 | 유형 | 예시 | 설명 |
| :--- | :--- | :--- | :--- |
| `pattern` | string | `"TODO.*fix"` | 검색할 정규식 패턴 |
| `path` | string | `"/path/to/dir"` | 선택적 검색할 파일 또는 디렉토리 |
| `glob` | string | `"*.ts"` | 선택적 파일을 필터링할 Glob 패턴 |
| `output_mode` | string | `"content"` | `"content"`, `"files_with_matches"`, 또는 `"count"` |

#### PreToolUse 입력 - WebFetch

| 필드 | 유형 | 예시 | 설명 |
| :--- | :--- | :--- | :--- |
| `url` | string | `"https://example.com/api"` | 콘텐츠를 가져올 URL |
| `prompt` | string | `"Extract the API endpoints"` | 가져온 콘텐츠에서 실행할 프롬프트 |

#### PreToolUse 입력 - WebSearch

| 필드 | 유형 | 예시 | 설명 |
| :--- | :--- | :--- | :--- |
| `query` | string | `"react hooks best practices"` | 검색 쿼리 |
| `allowed_domains` | array | `["docs.example.com"]` | 선택적: 이 도메인의 결과만 포함 |
| `blocked_domains` | array | `["spam.example.com"]` | 선택적: 이 도메인의 결과 제외 |

#### PreToolUse 입력 - Task

| 필드 | 유형 | 예시 | 설명 |
| :--- | :--- | :--- | :--- |
| `prompt` | string | `"Find all API endpoints"` | 에이전트가 수행할 작업 |
| `description` | string | `"Find API endpoints"` | 작업의 짧은 설명 |
| `subagent_type` | string | `"Explore"` | 사용할 특화된 에이전트 유형 |
| `model` | string | `"sonnet"` | 기본값을 재정의할 선택적 모델 별칭 |

#### PreToolUse 결정 제어

| 필드 | 설명 |
| :--- | :--- |
| `permissionDecision` | `"allow"`는 권한 시스템을 우회하고, `"deny"`는 도구 호출을 방지하며, `"ask"`는 사용자에게 요청 |
| `permissionDecisionReason` | `"allow"` 및 `"ask"`의 경우 사용자에게 표시되지만 Claude에게는 표시되지 않음. `"deny"`의 경우 Claude에게 표시 |
| `updatedInput` | 실행 전 도구의 입력 파라미터 수정 |
| `additionalContext` | 도구 실행 전 Claude의 컨텍스트에 추가된 문자열 |

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "allow",
    "permissionDecisionReason": "My reason here",
    "updatedInput": {
      "field_to_modify": "new value"
    },
    "additionalContext": "Current environment: production. Proceed with caution."
  }
}
```

### PermissionRequest

사용자에게 권한 대화상자가 표시될 때 실행됩니다. PreToolUse와 동일한 도구 이름에서 매칭됩니다.

#### PermissionRequest 입력

PermissionRequest hooks는 `tool_name` 및 `tool_input` 필드와 선택적 `permission_suggestions` 배열을 받습니다:

```json
{
  "session_id": "abc123",
  "hook_event_name": "PermissionRequest",
  "tool_name": "Bash",
  "tool_input": {
    "command": "rm -rf node_modules",
    "description": "Remove node_modules directory"
  },
  "permission_suggestions": [
    { "type": "toolAlwaysAllow", "tool": "Bash" }
  ]
}
```

#### PermissionRequest 결정 제어

| 필드 | 설명 |
| :--- | :--- |
| `behavior` | `"allow"`는 권한을 부여하고, `"deny"`는 거부 |
| `updatedInput` | `"allow"`에만 해당: 실행 전 도구의 입력 파라미터 수정 |
| `updatedPermissions` | `"allow"`에만 해당: 권한 규칙 업데이트 적용 |
| `message` | `"deny"`에만 해당: Claude에게 권한이 거부된 이유 알림 |
| `interrupt` | `"deny"`에만 해당: `true`이면 Claude 중단 |

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PermissionRequest",
    "decision": {
      "behavior": "allow",
      "updatedInput": {
        "command": "npm run lint"
      }
    }
  }
}
```

### PostToolUse

도구가 성공적으로 완료된 직후 실행됩니다. PreToolUse와 동일한 도구 이름에서 매칭됩니다.

#### PostToolUse 입력

입력에는 `tool_input` (도구에 전송된 인수)과 `tool_response` (반환된 결과) 모두 포함됩니다:

```json
{
  "session_id": "abc123",
  "hook_event_name": "PostToolUse",
  "tool_name": "Write",
  "tool_input": {
    "file_path": "/path/to/file.txt",
    "content": "file content"
  },
  "tool_response": {
    "filePath": "/path/to/file.txt",
    "success": true
  },
  "tool_use_id": "toolu_01ABC123..."
}
```

#### PostToolUse 결정 제어

| 필드 | 설명 |
| :--- | :--- |
| `decision` | `"block"`이면 `reason`과 함께 Claude에게 프롬프트. 동작이 진행되도록 허용하려면 생략 |
| `reason` | `decision`이 `"block"`인 경우 Claude에게 표시되는 설명 |
| `additionalContext` | Claude가 고려할 추가 컨텍스트 |
| `updatedMCPToolOutput` | MCP 도구에만 해당: 도구의 출력을 제공된 값으로 대체 |

```json
{
  "decision": "block",
  "reason": "Explanation for decision",
  "hookSpecificOutput": {
    "hookEventName": "PostToolUse",
    "additionalContext": "Additional information for Claude"
  }
}
```

### PostToolUseFailure

도구 실행이 실패할 때 실행됩니다. PreToolUse와 동일한 도구 이름에서 매칭됩니다.

#### PostToolUseFailure 입력

```json
{
  "session_id": "abc123",
  "hook_event_name": "PostToolUseFailure",
  "tool_name": "Bash",
  "tool_input": {
    "command": "npm test",
    "description": "Run test suite"
  },
  "tool_use_id": "toolu_01ABC123...",
  "error": "Command exited with non-zero status code 1",
  "is_interrupt": false
}
```

| 필드 | 설명 |
| :--- | :--- |
| `error` | 무엇이 잘못되었는지 설명하는 문자열 |
| `is_interrupt` | 실패가 사용자 인터럽트로 인한 것인지 나타내는 선택적 boolean |

#### PostToolUseFailure 결정 제어

| 필드 | 설명 |
| :--- | :--- |
| `additionalContext` | 오류와 함께 Claude가 고려할 추가 컨텍스트 |

### Notification

Claude Code가 알림을 전송할 때 실행됩니다. 알림 유형에서 매칭됩니다: `permission_prompt`, `idle_prompt`, `auth_success`, `elicitation_dialog`.

#### Notification 입력

공통 입력 필드 외에도 Notification hooks는 `message`, 선택적 `title`, `notification_type`을 받습니다:

```json
{
  "session_id": "abc123",
  "hook_event_name": "Notification",
  "message": "Claude needs your permission to use Bash",
  "title": "Permission needed",
  "notification_type": "permission_prompt"
}
```

`additionalContext`를 반환하여 대화에 컨텍스트를 추가할 수 있습니다.

### SubagentStart

Task 도구를 통해 Claude Code 서브에이전트가 생성될 때 실행됩니다.

#### SubagentStart 입력

공통 입력 필드 외에도 SubagentStart hooks는 `agent_id`와 `agent_type`을 받습니다:

```json
{
  "session_id": "abc123",
  "hook_event_name": "SubagentStart",
  "agent_id": "agent-abc123",
  "agent_type": "Explore"
}
```

SubagentStart hooks는 서브에이전트 생성을 차단할 수 없지만 컨텍스트를 주입할 수 있습니다:

| 필드 | 설명 |
| :--- | :--- |
| `additionalContext` | 서브에이전트의 컨텍스트에 추가된 문자열 |

### SubagentStop

Claude Code 서브에이전트가 응답을 완료했을 때 실행됩니다. SubagentStart와 동일한 에이전트 유형에서 매칭됩니다.

#### SubagentStop 입력

```json
{
  "session_id": "abc123",
  "hook_event_name": "SubagentStop",
  "stop_hook_active": false,
  "agent_id": "def456",
  "agent_type": "Explore",
  "agent_transcript_path": "~/.claude/projects/.../abc123/subagents/agent-def456.jsonl"
}
```

SubagentStop hooks는 Stop hooks와 동일한 결정 제어 형식을 사용합니다.

### Stop

메인 Claude Code 에이전트가 응답을 완료할 때 실행됩니다.

#### Stop 입력

공통 입력 필드 외에도 Stop hooks는 `stop_hook_active`를 받습니다:

```json
{
  "session_id": "abc123",
  "hook_event_name": "Stop",
  "stop_hook_active": true
}
```

#### Stop 결정 제어

| 필드 | 설명 |
| :--- | :--- |
| `decision` | `"block"`이면 Claude가 중단하지 못하도록 방지. Claude가 중단하도록 허용하려면 생략 |
| `reason` | `decision`이 `"block"`인 경우 필수. Claude에게 계속해야 하는 이유 알림 |

```json
{
  "decision": "block",
  "reason": "Must be provided when Claude is blocked from stopping"
}
```

### TeammateIdle

에이전트 팀 팀원이 유휴 상태가 되려 할 때 실행됩니다. `TeammateIdle` hook이 코드 2로 종료되면 팀원은 stderr 메시지를 피드백으로 받고 계속 작업합니다.

#### TeammateIdle 입력

```json
{
  "session_id": "abc123",
  "hook_event_name": "TeammateIdle",
  "teammate_name": "researcher",
  "team_name": "my-project"
}
```

#### TeammateIdle 결정 제어

TeammateIdle hooks는 종료 코드만 사용합니다:

```bash
#!/bin/bash

if [ ! -f "./dist/output.js" ]; then
  echo "Build artifact missing. Run the build before stopping." >&2
  exit 2
fi

exit 0
```

### TaskCompleted

작업이 완료로 표시될 때 실행됩니다. `TaskCompleted` hook이 코드 2로 종료되면 작업이 완료로 표시되지 않습니다.

#### TaskCompleted 입력

```json
{
  "session_id": "abc123",
  "hook_event_name": "TaskCompleted",
  "task_id": "task-001",
  "task_subject": "Implement user authentication",
  "task_description": "Add login and signup endpoints",
  "teammate_name": "implementer",
  "team_name": "my-project"
}
```

#### TaskCompleted 결정 제어

TaskCompleted hooks는 종료 코드만 사용합니다:

```bash
#!/bin/bash
INPUT=$(cat)
TASK_SUBJECT=$(echo "$INPUT" | jq -r '.task_subject')

# 테스트 스위트 실행
if ! npm test 2>&1; then
  echo "Tests not passing. Fix failing tests before completing: $TASK_SUBJECT" >&2
  exit 2
fi

exit 0
```

### PreCompact

Claude Code가 압축 작업을 실행하려 할 때 실행됩니다.

매처 값은 압축이 수동으로 트리거되었는지 자동으로 트리거되었는지 나타냅니다:

| 매처 | 발동 시점 |
| :--- | :--- |
| `manual` | `/compact` |
| `auto` | 컨텍스트 창이 가득 찰 때 자동 압축 |

#### PreCompact 입력

```json
{
  "session_id": "abc123",
  "hook_event_name": "PreCompact",
  "trigger": "manual",
  "custom_instructions": ""
}
```

### SessionEnd

Claude Code 세션이 종료될 때 실행됩니다.

`reason` 필드는 세션이 종료된 이유를 나타냅니다:

| 이유 | 설명 |
| :--- | :--- |
| `clear` | `/clear` 명령으로 세션이 지워짐 |
| `logout` | 사용자가 로그아웃함 |
| `prompt_input_exit` | 프롬프트 입력이 표시된 상태에서 사용자가 종료함 |
| `bypass_permissions_disabled` | 권한 우회 모드가 비활성화됨 |
| `other` | 기타 종료 이유 |

#### SessionEnd 입력

```json
{
  "session_id": "abc123",
  "hook_event_name": "SessionEnd",
  "reason": "other"
}
```

SessionEnd hooks에는 결정 제어가 없습니다. 세션 종료를 차단할 수 없지만 정리 작업을 수행할 수 있습니다.

## 프롬프트 기반 Hooks

프롬프트 기반 hooks (`type: "prompt"`)는 LLM을 사용하여 동작을 허용할지 차단할지 평가합니다.

### 프롬프트 기반 Hooks의 작동 방식

1. hook 입력과 프롬프트를 Claude 모델(기본적으로 Haiku)에 전송
2. LLM이 결정을 포함한 구조화된 JSON으로 응답
3. Claude Code가 결정을 자동으로 처리

### 프롬프트 Hook 구성

```json
{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "Evaluate if Claude should stop: $ARGUMENTS. Check if all tasks are complete."
          }
        ]
      }
    ]
  }
}
```

| 필드 | 필수 | 설명 |
| :--- | :--- | :--- |
| `type` | 예 | `"prompt"`여야 함 |
| `prompt` | 예 | LLM에 전송할 프롬프트 텍스트. `$ARGUMENTS`를 플레이스홀더로 사용 |
| `model` | 아니요 | 평가에 사용할 모델. 기본값은 빠른 모델 |
| `timeout` | 아니요 | 초 단위 타임아웃. 기본값: 30 |

### 응답 스키마

```json
{
  "ok": true,
  "reason": "Explanation for the decision"
}
```

| 필드 | 설명 |
| :--- | :--- |
| `ok` | `true`는 동작을 허용하고, `false`는 방지 |
| `reason` | `ok`가 `false`인 경우 필수. Claude에게 표시되는 설명 |

### 예시: 다중 기준 Stop hook

```json
{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "You are evaluating whether Claude should stop working. Context: $ARGUMENTS\n\nAnalyze the conversation and determine if:\n1. All user-requested tasks are complete\n2. Any errors need to be addressed\n3. Follow-up work is needed\n\nRespond with JSON: {\"ok\": true} to allow stopping, or {\"ok\": false, \"reason\": \"your explanation\"} to continue working.",
            "timeout": 30
          }
        ]
      }
    ]
  }
}
```

## 에이전트 기반 Hooks

에이전트 기반 hooks (`type: "agent"`)는 프롬프트 기반 hooks와 비슷하지만 다중 턴 도구 접근이 있습니다. 에이전트 hook은 파일을 읽고, 코드를 검색하고, 코드베이스를 검사하여 조건을 검증할 수 있는 서브에이전트를 생성합니다.

### 에이전트 Hooks의 작동 방식

1. Claude Code가 프롬프트와 hook의 JSON 입력으로 서브에이전트를 생성
2. 서브에이전트는 Read, Grep, Glob과 같은 도구를 사용하여 조사할 수 있음
3. 최대 50 턴 후 서브에이전트가 구조화된 `{ "ok": true/false }` 결정을 반환

### 에이전트 Hook 구성

| 필드 | 필수 | 설명 |
| :--- | :--- | :--- |
| `type` | 예 | `"agent"`여야 함 |
| `prompt` | 예 | 검증할 내용을 설명하는 프롬프트 |
| `model` | 아니요 | 사용할 모델. 기본값은 빠른 모델 |
| `timeout` | 아니요 | 초 단위 타임아웃. 기본값: 60 |

예시 - Claude가 완료하도록 허용하기 전에 테스트가 통과하는지 검증:

```json
{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "agent",
            "prompt": "Verify that all unit tests pass. Run the test suite and check the results. $ARGUMENTS",
            "timeout": 120
          }
        ]
      }
    ]
  }
}
```

## 백그라운드에서 Hooks 실행

`"async": true`를 설정하면 Claude가 계속 작업하는 동안 hook이 백그라운드에서 실행됩니다. 비동기 hooks는 Claude의 동작을 차단하거나 제어할 수 없습니다.

### 비동기 Hook 구성

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write",
        "hooks": [
          {
            "type": "command",
            "command": "/path/to/run-tests.sh",
            "async": true,
            "timeout": 120
          }
        ]
      }
    ]
  }
}
```

### 예시: 파일 변경 후 테스트 실행

`.claude/hooks/run-tests-async.sh`에 이 스크립트를 저장합니다:

```bash
#!/bin/bash
# run-tests-async.sh

# stdin에서 hook 입력 읽기
INPUT=$(cat)
FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // empty')

# 소스 파일에만 테스트 실행
if [[ "$FILE_PATH" != *.ts && "$FILE_PATH" != *.js ]]; then
  exit 0
fi

# 테스트 실행 및 systemMessage를 통해 결과 보고
RESULT=$(npm test 2>&1)
EXIT_CODE=$?

if [ $EXIT_CODE -eq 0 ]; then
  echo "{\"systemMessage\": \"Tests passed after editing $FILE_PATH\"}"
else
  echo "{\"systemMessage\": \"Tests failed after editing $FILE_PATH: $RESULT\"}"
fi
```

`.claude/settings.json`에 추가:

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/run-tests-async.sh",
            "async": true,
            "timeout": 300
          }
        ]
      }
    ]
  }
}
```

### 제한 사항

* `type: "command"` hooks만 `async`를 지원합니다
* 비동기 hooks는 도구 호출을 차단하거나 결정을 반환할 수 없습니다
* Hook 출력은 다음 대화 턴에서 전달됩니다
* 각 실행은 별도의 백그라운드 프로세스를 만듭니다

## 보안 고려 사항

> Hooks는 시스템 사용자의 전체 권한으로 실행됩니다. 사용자 계정이 접근할 수 있는 모든 파일을 수정, 삭제 또는 접근할 수 있습니다. 구성에 추가하기 전에 모든 hook 명령을 검토하고 테스트하세요.

### 보안 모범 사례

* **입력 검증 및 삭제**: 입력 데이터를 맹목적으로 신뢰하지 마세요
* **항상 셸 변수를 따옴표로 묶기**: `$VAR`이 아닌 `"$VAR"` 사용
* **경로 순회 차단**: 파일 경로에서 `..` 확인
* **절대 경로 사용**: 스크립트의 전체 경로를 지정하고, 프로젝트 루트에 `"$CLAUDE_PROJECT_DIR"` 사용
* **민감한 파일 건너뛰기**: `.env`, `.git/`, 키 등 피하기

## Hooks 디버그

`claude --debug`를 실행하여 일치한 hooks, 종료 코드, 출력을 포함한 hook 실행 세부 정보를 확인하세요. `Ctrl+O`로 상세 모드를 전환하면 트랜스크립트에서 hook 진행 상황을 볼 수 있습니다.

```
[DEBUG] Executing hooks for PostToolUse:Write
[DEBUG] Getting matching hook commands for PostToolUse with query: Write
[DEBUG] Found 1 hook matchers in settings
[DEBUG] Matched 1 hooks for query "Write"
[DEBUG] Found 1 hook commands to execute
[DEBUG] Executing hook command: <Your command> with timeout 600000ms
[DEBUG] Hook command completed with status 0: <Your stdout>
```

일반적인 문제 해결은 hooks 가이드의 제한 사항 및 문제 해결을 참조하세요.
