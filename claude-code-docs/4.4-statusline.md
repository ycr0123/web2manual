---
title: "Customize your status line"
titleKo: "상태줄 커스터마이즈"
description: "Configure a custom status bar to monitor context window usage, costs, and git status in Claude Code"
descriptionKo: "컨텍스트 창 사용량, 비용, git 상태를 모니터링하는 커스텀 상태 표시줄을 구성합니다."
category: "settings"
sourceUrl: "https://code.claude.com/docs/en/statusline.md"
fetchedDate: "2026-02-19"
---

# Source: https://code.claude.com/docs/en/statusline.md

# 상태줄 커스터마이즈

> Claude Code에서 컨텍스트 창 사용량, 비용, git 상태를 모니터링하는 커스텀 상태 표시줄을 구성합니다

상태줄은 Claude Code 하단에 있는 커스터마이즈 가능한 바로, 구성한 셸 스크립트를 실행합니다. stdin으로 JSON 세션 데이터를 받아 스크립트가 출력하는 내용을 표시하여, 컨텍스트 사용량, 비용, git 상태 등 원하는 것을 항상 한눈에 볼 수 있습니다.

상태줄은 다음과 같은 경우에 유용합니다:

* 작업하면서 컨텍스트 창 사용량을 모니터링하려는 경우
* 세션 비용을 추적해야 하는 경우
* 여러 세션에 걸쳐 작업하고 세션을 구별해야 하는 경우
* git 브랜치와 상태를 항상 표시하려는 경우

## 상태줄 설정

[`/statusline` 명령](#use-the-statusline-command)을 사용하여 Claude Code가 스크립트를 생성하도록 하거나, [수동으로 스크립트를 만들고](#manually-configure-a-status-line) 설정에 추가하세요.

### /statusline 명령 사용

`/statusline` 명령은 표시하려는 내용을 설명하는 자연어 지침을 받습니다. Claude Code가 `~/.claude/`에 스크립트 파일을 생성하고 설정을 자동으로 업데이트합니다:

```
/statusline show model name and context percentage with a progress bar
```

### 수동으로 상태줄 구성

사용자 설정(`~/.claude/settings.json`) 또는 [프로젝트 설정](/en/settings#settings-files)에 `statusLine` 필드를 추가합니다. `type`을 `"command"`로 설정하고 `command`를 스크립트 경로 또는 인라인 셸 명령으로 지정합니다.

```json
{
  "statusLine": {
    "type": "command",
    "command": "~/.claude/statusline.sh",
    "padding": 2
  }
}
```

`command` 필드는 셸에서 실행되므로 스크립트 파일 대신 인라인 명령을 사용할 수도 있습니다. 이 예시는 `jq`를 사용하여 JSON 입력을 파싱하고 모델 이름과 컨텍스트 비율을 표시합니다:

```json
{
  "statusLine": {
    "type": "command",
    "command": "jq -r '\"[\\(.model.display_name)] \\(.context_window.used_percentage // 0)% context\"'"
  }
}
```

선택적 `padding` 필드는 상태줄 내용에 추가 가로 공백(문자 단위)을 추가합니다. 기본값은 `0`입니다.

### 상태줄 비활성화

`/statusline`을 실행하고 상태줄을 제거하거나 지우도록 요청하세요 (예: `/statusline delete`, `/statusline clear`, `/statusline remove it`). 설정.json에서 `statusLine` 필드를 수동으로 삭제할 수도 있습니다.

## 단계별 상태줄 구축

이 연습은 현재 모델, 작업 디렉토리, 컨텍스트 창 사용 비율을 표시하는 상태줄을 수동으로 만들어보면서 내부적으로 어떻게 작동하는지 보여줍니다.

> **참고**: 원하는 내용을 설명하여 [`/statusline`](#use-the-statusline-command)을 실행하면 이 모든 것이 자동으로 구성됩니다.

이 예시는 macOS와 Linux에서 작동하는 Bash 스크립트를 사용합니다. Windows에서는 WSL을 통해 Bash 스크립트를 실행하거나 PowerShell로 다시 작성할 수 있습니다.

### 1단계: JSON을 읽고 출력을 인쇄하는 스크립트 만들기

Claude Code는 stdin을 통해 스크립트에 JSON 데이터를 전송합니다. 이 스크립트는 `jq`를 사용하여 모델 이름, 디렉토리, 컨텍스트 비율을 추출한 다음 형식화된 줄을 인쇄합니다.

`~/.claude/statusline.sh`에 저장합니다:

```bash
#!/bin/bash
# Claude Code가 stdin으로 보내는 JSON 데이터를 읽습니다
input=$(cat)

# jq를 사용하여 필드를 추출합니다
MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir')
# "// 0"은 필드가 null인 경우 폴백을 제공합니다
PCT=$(echo "$input" | jq -r '.context_window.used_percentage // 0' | cut -d. -f1)

# 상태줄을 출력합니다 - ${DIR##*/}는 폴더 이름만 추출합니다
echo "[$MODEL] $(DIR) | ${PCT}% context"
```

### 2단계: 실행 가능하게 만들기

셸이 스크립트를 실행할 수 있도록 실행 가능으로 표시합니다:

```bash
chmod +x ~/.claude/statusline.sh
```

### 3단계: 설정에 추가

Claude Code에 스크립트를 상태줄로 실행하도록 지시합니다. `~/.claude/settings.json`에 이 구성을 추가합니다:

```json
{
  "statusLine": {
    "type": "command",
    "command": "~/.claude/statusline.sh"
  }
}
```

상태줄이 인터페이스 하단에 나타납니다. 설정은 자동으로 다시 로드되지만 Claude Code와의 다음 상호 작용이 있을 때까지 변경 사항이 표시되지 않습니다.

## 상태줄의 작동 방식

Claude Code는 스크립트를 실행하고 stdin을 통해 JSON 세션 데이터를 파이프합니다. 스크립트는 JSON을 읽고, 필요한 내용을 추출하고, stdout에 텍스트를 인쇄합니다. Claude Code는 스크립트가 인쇄하는 내용을 표시합니다.

**업데이트 시점**

스크립트는 새로운 어시스턴트 메시지가 있을 때, 권한 모드가 변경될 때, vim 모드가 전환될 때 실행됩니다. 업데이트는 300ms에서 디바운스됩니다. 스크립트가 아직 실행 중인 동안 새로운 업데이트가 트리거되면 진행 중인 실행이 취소됩니다. 스크립트를 편집한 경우, Claude Code와의 다음 상호 작용이 업데이트를 트리거할 때까지 변경 사항이 나타나지 않습니다.

**스크립트가 출력할 수 있는 내용**

* **여러 줄**: 각 `echo` 또는 `print` 문이 별도의 행으로 표시됩니다.
* **색상**: 초록색의 경우 `\033[32m`과 같은 ANSI 이스케이프 코드를 사용합니다 (터미널이 지원해야 함).
* **링크**: OSC 8 이스케이프 시퀀스를 사용하여 텍스트를 클릭 가능하게 만듭니다 (macOS에서는 Cmd+클릭, Windows/Linux에서는 Ctrl+클릭).

> **참고**: 상태줄은 로컬에서 실행되며 API 토큰을 소비하지 않습니다. 자동 완성 제안, 도움말 메뉴, 권한 프롬프트를 포함한 특정 UI 상호 작용 중에 일시적으로 숨겨집니다.

## 사용 가능한 데이터

Claude Code는 stdin을 통해 다음 JSON 필드를 스크립트에 전송합니다:

| 필드 | 설명 |
| ------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `model.id`, `model.display_name` | 현재 모델 식별자 및 표시 이름 |
| `cwd`, `workspace.current_dir` | 현재 작업 디렉토리. 두 필드 모두 동일한 값을 포함하며, `workspace.project_dir`과의 일관성을 위해 `workspace.current_dir`이 권장됩니다. |
| `workspace.project_dir` | Claude Code가 시작된 디렉토리로, 세션 중 작업 디렉토리가 변경된 경우 `cwd`와 다를 수 있습니다 |
| `cost.total_cost_usd` | USD 기준 총 세션 비용 |
| `cost.total_duration_ms` | 세션이 시작된 이후 총 실제 경과 시간(밀리초) |
| `cost.total_api_duration_ms` | API 응답을 기다리는 데 소비된 총 시간(밀리초) |
| `cost.total_lines_added`, `cost.total_lines_removed` | 변경된 코드 줄 수 |
| `context_window.total_input_tokens`, `context_window.total_output_tokens` | 세션 전체의 누적 토큰 수 |
| `context_window.context_window_size` | 최대 컨텍스트 창 크기(토큰). 기본적으로 200000, 확장 컨텍스트가 있는 모델의 경우 1000000. |
| `context_window.used_percentage` | 사용된 컨텍스트 창의 사전 계산된 비율 |
| `context_window.remaining_percentage` | 남은 컨텍스트 창의 사전 계산된 비율 |
| `context_window.current_usage` | 마지막 API 호출의 토큰 수 |
| `exceeds_200k_tokens` | 가장 최근 API 응답의 총 토큰 수가 200k를 초과하는지 여부. |
| `session_id` | 고유 세션 식별자 |
| `transcript_path` | 대화 트랜스크립트 파일 경로 |
| `version` | Claude Code 버전 |
| `output_style.name` | 현재 출력 스타일 이름 |
| `vim.mode` | vim 모드가 활성화된 경우 현재 vim 모드 (`NORMAL` 또는 `INSERT`) |
| `agent.name` | `--agent` 플래그로 실행하거나 에이전트 설정이 구성된 경우 에이전트 이름 |

### 컨텍스트 창 필드

`context_window` 객체는 컨텍스트 사용량을 추적하는 두 가지 방법을 제공합니다:

* **누적 합계** (`total_input_tokens`, `total_output_tokens`): 전체 세션에 걸친 모든 토큰의 합계로, 총 소비량을 추적하는 데 유용합니다
* **현재 사용량** (`current_usage`): 가장 최근 API 호출의 토큰 수로, 실제 컨텍스트 상태를 반영하므로 정확한 컨텍스트 비율을 위해 이것을 사용하세요

`current_usage` 객체에는 다음이 포함됩니다:

* `input_tokens`: 현재 컨텍스트의 입력 토큰
* `output_tokens`: 생성된 출력 토큰
* `cache_creation_input_tokens`: 캐시에 기록된 토큰
* `cache_read_input_tokens`: 캐시에서 읽은 토큰

`used_percentage` 필드는 입력 토큰만으로 계산됩니다: `input_tokens + cache_creation_input_tokens + cache_read_input_tokens`. `output_tokens`는 포함되지 않습니다.

`current_usage` 객체는 세션의 첫 번째 API 호출 전에는 `null`입니다.

## 예시

### 컨텍스트 창 사용량

현재 모델과 시각적 진행 표시줄이 있는 컨텍스트 창 사용량을 표시합니다:

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
PCT=$(echo "$input" | jq -r '.context_window.used_percentage // 0' | cut -d. -f1)

BAR_WIDTH=10
FILLED=$((PCT * BAR_WIDTH / 100))
EMPTY=$((BAR_WIDTH - FILLED))
BAR=""
[ "$FILLED" -gt 0 ] && BAR=$(printf "%${FILLED}s" | tr ' ' '▓')
[ "$EMPTY" -gt 0 ] && BAR="${BAR}$(printf "%${EMPTY}s" | tr ' ' '░')"

echo "[$MODEL] $BAR $PCT%"
```

### 색상이 있는 Git 상태

스테이징된 파일 및 수정된 파일에 대한 색상 코드 표시기와 함께 git 브랜치를 표시합니다:

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir')

GREEN='\033[32m'
YELLOW='\033[33m'
RESET='\033[0m'

if git rev-parse --git-dir > /dev/null 2>&1; then
    BRANCH=$(git branch --show-current 2>/dev/null)
    STAGED=$(git diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
    MODIFIED=$(git diff --numstat 2>/dev/null | wc -l | tr -d ' ')

    GIT_STATUS=""
    [ "$STAGED" -gt 0 ] && GIT_STATUS="${GREEN}+${STAGED}${RESET}"
    [ "$MODIFIED" -gt 0 ] && GIT_STATUS="${GIT_STATUS}${YELLOW}~${MODIFIED}${RESET}"

    echo -e "[$MODEL] $(DIR##*/) | 🌿 $BRANCH $GIT_STATUS"
else
    echo "[$MODEL] $(DIR##*/)"
fi
```

### 비용 및 지속 시간 추적

세션의 API 비용과 경과 시간을 추적합니다:

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
COST=$(echo "$input" | jq -r '.cost.total_cost_usd // 0')
DURATION_MS=$(echo "$input" | jq -r '.cost.total_duration_ms // 0')

COST_FMT=$(printf '$%.2f' "$COST")
DURATION_SEC=$((DURATION_MS / 1000))
MINS=$((DURATION_SEC / 60))
SECS=$((DURATION_SEC % 60))

echo "[$MODEL] 💰 $COST_FMT | ⏱️ ${MINS}m ${SECS}s"
```

### 여러 줄 표시

스크립트는 여러 줄을 출력하여 더 풍부한 디스플레이를 만들 수 있습니다. 각 `echo` 문이 상태 영역에 별도의 행을 생성합니다:

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir')
COST=$(echo "$input" | jq -r '.cost.total_cost_usd // 0')
PCT=$(echo "$input" | jq -r '.context_window.used_percentage // 0' | cut -d. -f1)
DURATION_MS=$(echo "$input" | jq -r '.cost.total_duration_ms // 0')

CYAN='\033[36m'; GREEN='\033[32m'; YELLOW='\033[33m'; RED='\033[31m'; RESET='\033[0m'

if [ "$PCT" -ge 90 ]; then BAR_COLOR="$RED"
elif [ "$PCT" -ge 70 ]; then BAR_COLOR="$YELLOW"
else BAR_COLOR="$GREEN"; fi

FILLED=$((PCT / 10)); EMPTY=$((10 - FILLED))
BAR=$(printf "%${FILLED}s" | tr ' ' '█')$(printf "%${EMPTY}s" | tr ' ' '░')

MINS=$((DURATION_MS / 60000)); SECS=$(((DURATION_MS % 60000) / 1000))

BRANCH=""
git rev-parse --git-dir > /dev/null 2>&1 && BRANCH=" | 🌿 $(git branch --show-current 2>/dev/null)"

echo -e "${CYAN}[$MODEL]${RESET} 📁 ${DIR##*/}$BRANCH"
COST_FMT=$(printf '$%.2f' "$COST")
echo -e "${BAR_COLOR}${BAR}${RESET} ${PCT}% | ${YELLOW}${COST_FMT}${RESET} | ⏱️ ${MINS}m ${SECS}s"
```

## 팁

* **모의 입력으로 테스트**: `echo '{"model":{"display_name":"Opus"},"context_window":{"used_percentage":25}}' | ./statusline.sh`
* **출력을 짧게 유지**: 상태 표시줄은 너비가 제한되어 있으므로 긴 출력이 잘리거나 어색하게 줄 바꿈될 수 있습니다
* **느린 작업 캐싱**: 스크립트는 활성 세션 중에 자주 실행되므로 `git status`와 같은 명령이 지연을 초래할 수 있습니다.

## 문제 해결

**상태줄이 표시되지 않는 경우**

* 스크립트가 실행 가능한지 확인: `chmod +x ~/.claude/statusline.sh`
* 스크립트가 stderr가 아닌 stdout으로 출력하는지 확인
* 스크립트를 수동으로 실행하여 출력이 생성되는지 확인
* 설정에서 `disableAllHooks`가 `true`로 설정된 경우 상태줄도 비활성화됩니다.

**상태줄에 `--` 또는 빈 값이 표시되는 경우**

* 첫 번째 API 응답이 완료되기 전에 필드가 `null`일 수 있습니다
* jq의 `// 0`과 같은 폴백으로 스크립트에서 null 값을 처리하세요
* 여러 메시지 후에도 값이 비어 있으면 Claude Code를 재시작하세요

**컨텍스트 비율이 예상치 못한 값을 표시하는 경우**

* 정확한 컨텍스트 상태를 위해 누적 합계 대신 `used_percentage`를 사용하세요
* `total_input_tokens`와 `total_output_tokens`는 세션 전체에 걸쳐 누적되며 컨텍스트 창 크기를 초과할 수 있습니다

**스크립트 오류 또는 중단**

* 0이 아닌 코드로 종료하거나 출력을 생성하지 않는 스크립트는 상태줄이 비어지게 합니다
* 느린 스크립트는 완료될 때까지 상태줄 업데이트를 차단합니다.
* 구성하기 전에 모의 입력으로 스크립트를 독립적으로 테스트하세요
