---
title: "Automate workflows with hooks"
titleKo: "훅으로 워크플로우 자동화"
description: "Run shell commands automatically when Claude Code edits files, finishes tasks, or needs input."
descriptionKo: "파일 편집, 작업 완료, 입력 필요 시 자동으로 셸 명령을 실행합니다."
source: https://code.claude.com/docs/en/hooks-guide.md
fetched: 2026-02-18
section: 6.10
---

# 훅으로 워크플로우 자동화

> Claude Code가 파일을 편집하거나 작업을 완료하거나 입력이 필요할 때 셸 명령을 자동으로 실행합니다. 코드 서식 지정, 알림 전송, 명령 유효성 검사, 프로젝트 규칙 적용.

Hooks는 Claude Code의 라이프사이클의 특정 지점에서 실행되는 사용자 정의 셸 명령입니다. LLM이 선택하는 것에 의존하는 대신 특정 작업이 항상 발생하도록 보장하는 Claude Code 동작에 대한 결정론적 제어를 제공합니다. hooks를 사용하여 프로젝트 규칙을 적용하고, 반복 작업을 자동화하며, Claude Code를 기존 도구와 통합하세요.

판단이 필요한 결정의 경우, Claude 모델을 사용하여 조건을 평가하는 프롬프트 기반 hooks 또는 에이전트 기반 hooks를 사용할 수도 있습니다.

> 이 가이드는 일반적인 사용 사례와 시작하는 방법을 다룹니다. 전체 이벤트 스키마, JSON 입출력 형식, 비동기 hooks 및 MCP 도구 hooks와 같은 고급 기능은 Hooks 레퍼런스를 참조하세요.

## 첫 번째 Hook 설정

Hook를 만드는 가장 빠른 방법은 Claude Code의 `/hooks` 대화형 메뉴를 통하는 것입니다. 이 연습은 데스크톱 알림 hook을 만듭니다.

**1단계: hooks 메뉴 열기**

Claude Code CLI에서 `/hooks`를 입력합니다. 사용 가능한 모든 hook 이벤트 목록이 표시됩니다. Claude가 주의를 요할 때 발동하는 hook을 만들기 위해 `Notification`을 선택합니다.

**2단계: 매처 구성**

모든 알림 유형에서 발동하도록 매처를 `*`로 설정합니다.

**3단계: 명령 추가**

`+ Add new hook…`을 선택합니다. 운영 체제에 맞는 명령을 복사합니다:

**macOS:**

```
osascript -e 'display notification "Claude Code needs your attention" with title "Claude Code"'
```

**Linux:**

```
notify-send 'Claude Code' 'Claude Code needs your attention'
```

**Windows (PowerShell):**

```
powershell.exe -Command "[System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms'); [System.Windows.Forms.MessageBox]::Show('Claude Code needs your attention', 'Claude Code')"
```

**4단계: 저장 위치 선택**

`User settings`를 선택하여 `~/.claude/settings.json`에 저장합니다. 이렇게 하면 모든 프로젝트에 hook이 적용됩니다.

**5단계: Hook 테스트**

`Esc`를 눌러 CLI로 돌아갑니다. Claude에게 권한이 필요한 무언가를 요청한 다음 터미널에서 다른 곳으로 이동하세요. 데스크톱 알림을 받아야 합니다.

## 자동화할 수 있는 것

### Claude가 입력이 필요할 때 알림 받기

**macOS:**

```json
{
  "hooks": {
    "Notification": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "osascript -e 'display notification \"Claude Code needs your attention\" with title \"Claude Code\"'"
          }
        ]
      }
    ]
  }
}
```

**Linux:**

```json
{
  "hooks": {
    "Notification": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "notify-send 'Claude Code' 'Claude Code needs your attention'"
          }
        ]
      }
    ]
  }
}
```

**Windows (PowerShell):**

```json
{
  "hooks": {
    "Notification": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "powershell.exe -Command \"[System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms'); [System.Windows.Forms.MessageBox]::Show('Claude Code needs your attention', 'Claude Code')\""
          }
        ]
      }
    ]
  }
}
```

### 편집 후 코드 자동 서식 지정

Claude가 편집하는 모든 파일에서 Prettier를 자동으로 실행합니다:

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '.tool_input.file_path' | xargs npx prettier --write"
          }
        ]
      }
    ]
  }
}
```

> 이 페이지의 Bash 예시는 JSON 파싱을 위해 `jq`를 사용합니다. `brew install jq` (macOS), `apt-get install jq` (Debian/Ubuntu)로 설치하세요.

### 보호된 파일에 대한 편집 차단

**1단계: Hook 스크립트 만들기**

`.claude/hooks/protect-files.sh`에 저장합니다:

```bash
#!/bin/bash
# protect-files.sh

INPUT=$(cat)
FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // empty')

PROTECTED_PATTERNS=(".env" "package-lock.json" ".git/")

for pattern in "${PROTECTED_PATTERNS[@]}"; do
  if [[ "$FILE_PATH" == *"$pattern"* ]]; then
    echo "Blocked: $FILE_PATH matches protected pattern '$pattern'" >&2
    exit 2
  fi
done

exit 0
```

**2단계: 스크립트를 실행 가능하게 만들기 (macOS/Linux)**

```bash
chmod +x .claude/hooks/protect-files.sh
```

**3단계: Hook 등록**

`.claude/settings.json`에 `PreToolUse` hook을 추가합니다:

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/protect-files.sh"
          }
        ]
      }
    ]
  }
}
```

### 압축 후 컨텍스트 재주입

```json
{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "compact",
        "hooks": [
          {
            "type": "command",
            "command": "echo 'Reminder: use Bun, not npm. Run bun test before committing. Current sprint: auth refactor.'"
          }
        ]
      }
    ]
  }
}
```

## Hooks의 작동 방식

Hook 이벤트는 Claude Code의 특정 라이프사이클 지점에서 발동합니다. 이벤트가 발동하면 모든 일치하는 hooks가 병렬로 실행되고 동일한 hook 명령은 자동으로 중복 제거됩니다.

| 이벤트 | 발동 시점 |
| :--- | :--- |
| `SessionStart` | 세션이 시작되거나 재개될 때 |
| `UserPromptSubmit` | 프롬프트를 제출할 때, Claude가 처리하기 전 |
| `PreToolUse` | 도구 호출이 실행되기 전. 차단할 수 있음 |
| `PermissionRequest` | 권한 대화상자가 나타날 때 |
| `PostToolUse` | 도구 호출이 성공한 후 |
| `PostToolUseFailure` | 도구 호출이 실패한 후 |
| `Notification` | Claude Code가 알림을 전송할 때 |
| `SubagentStart` | 서브에이전트가 생성될 때 |
| `SubagentStop` | 서브에이전트가 완료될 때 |
| `Stop` | Claude가 응답을 완료할 때 |
| `TeammateIdle` | 에이전트 팀 팀원이 유휴 상태가 되려 할 때 |
| `TaskCompleted` | 작업이 완료로 표시될 때 |
| `PreCompact` | 컨텍스트 압축 전 |
| `SessionEnd` | 세션이 종료될 때 |

각 hook에는 실행 방법을 결정하는 `type`이 있습니다. 대부분의 hooks는 `"type": "command"`를 사용합니다. 다른 두 옵션은 Claude 모델을 사용합니다: `"type": "prompt"`는 단일 턴 평가를 위한 것이고 `"type": "agent"`는 도구 접근이 있는 다중 턴 검증을 위한 것입니다.

### 입력 읽기 및 출력 반환

Hooks는 stdin, stdout, stderr 및 종료 코드를 통해 Claude Code와 통신합니다. 이벤트가 발동하면 Claude Code가 이벤트별 데이터를 JSON으로 스크립트의 stdin에 전달합니다.

예를 들어, Claude가 Bash 명령을 실행하면 `PreToolUse` hook은 stdin에서 다음과 같은 내용을 받습니다:

```json
{
  "session_id": "abc123",
  "cwd": "/Users/sarah/myproject",
  "hook_event_name": "PreToolUse",
  "tool_name": "Bash",
  "tool_input": {
    "command": "npm test"
  }
}
```

#### Hook 출력

스크립트는 stdout 또는 stderr에 쓰고 특정 코드로 종료하여 Claude Code에게 다음에 할 일을 알립니다:

* **Exit 0**: 작업이 진행됩니다. `UserPromptSubmit` 및 `SessionStart` hooks의 경우, stdout에 쓴 내용이 Claude의 컨텍스트에 추가됩니다.
* **Exit 2**: 작업이 차단됩니다. stderr에 이유를 쓰면 Claude가 피드백으로 받습니다.
* **다른 종료 코드**: 작업이 진행됩니다. stderr는 기록되지만 Claude에게 표시되지 않습니다.

#### 구조화된 JSON 출력

더 많은 제어를 위해 exit 0으로 종료하고 stdout에 JSON 객체를 인쇄합니다:

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "deny",
    "permissionDecisionReason": "Use rg instead of grep for better performance"
  }
}
```

### 매처로 Hooks 필터링

매처 없이는 hook이 이벤트가 발생할 때마다 발동합니다. 매처를 사용하면 범위를 좁힐 수 있습니다:

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          { "type": "command", "command": "prettier --write ..." }
        ]
      }
    ]
  }
}
```

각 이벤트 유형은 특정 필드에서 매칭됩니다:

| 이벤트 | 매처가 필터링하는 것 | 예시 매처 값 |
| :--- | :--- | :--- |
| `PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `PermissionRequest` | 도구 이름 | `Bash`, `Edit\|Write`, `mcp__.*` |
| `SessionStart` | 세션이 시작된 방법 | `startup`, `resume`, `clear`, `compact` |
| `SessionEnd` | 세션이 종료된 이유 | `clear`, `logout`, `prompt_input_exit`, `bypass_permissions_disabled`, `other` |
| `Notification` | 알림 유형 | `permission_prompt`, `idle_prompt`, `auth_success`, `elicitation_dialog` |
| `SubagentStart` | 에이전트 유형 | `Bash`, `Explore`, `Plan` 또는 커스텀 에이전트 이름 |
| `PreCompact` | 압축을 트리거한 것 | `manual`, `auto` |
| `UserPromptSubmit`, `Stop`, `TeammateIdle`, `TaskCompleted` | 매처 지원 없음 | 모든 발생 시마다 항상 발동 |

#### 매처 예시

**모든 Bash 명령 로그:**

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '.tool_input.command' >> ~/.claude/command-log.txt"
          }
        ]
      }
    ]
  }
}
```

**MCP 도구 매칭:**

MCP 도구는 `mcp__<server>__<tool>` 명명 규칙을 사용합니다:

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "mcp__github__.*",
        "hooks": [
          {
            "type": "command",
            "command": "echo \"GitHub tool called: $(jq -r '.tool_name')\" >&2"
          }
        ]
      }
    ]
  }
}
```

**세션 종료 시 정리:**

```json
{
  "hooks": {
    "SessionEnd": [
      {
        "matcher": "clear",
        "hooks": [
          {
            "type": "command",
            "command": "rm -f /tmp/claude-scratch-*.txt"
          }
        ]
      }
    ]
  }
}
```

### Hook 위치 구성

Hook를 추가하는 위치에 따라 범위가 결정됩니다:

| 위치 | 범위 | 공유 가능 |
| :--- | :--- | :--- |
| `~/.claude/settings.json` | 모든 프로젝트 | 아니요, 머신 로컬 |
| `.claude/settings.json` | 단일 프로젝트 | 예, 저장소에 커밋 가능 |
| `.claude/settings.local.json` | 단일 프로젝트 | 아니요, gitignore됨 |
| Managed 정책 설정 | 조직 전체 | 예, 관리자가 제어 |
| 플러그인 `hooks/hooks.json` | 플러그인이 활성화된 경우 | 예, 플러그인과 번들됨 |
| 스킬 또는 에이전트 frontmatter | 스킬 또는 에이전트가 활성화된 동안 | 예, 컴포넌트 파일에 정의됨 |

`/hooks` 메뉴를 통해 추가된 hooks는 즉시 적용됩니다. Claude Code가 실행되는 동안 설정 파일을 직접 편집하면 `/hooks` 메뉴에서 검토하거나 세션을 재시작할 때까지 변경 사항이 적용되지 않습니다.

## 프롬프트 기반 Hooks

결정론적 규칙이 아닌 판단이 필요한 결정의 경우, `type: "prompt"` hooks를 사용하세요. 셸 명령을 실행하는 대신, Claude Code가 프롬프트와 hook의 입력 데이터를 Claude 모델(기본적으로 Haiku)에 전송하여 결정합니다.

모델의 유일한 작업은 결정을 JSON으로 반환하는 것입니다:

* `"ok": true`: 작업이 진행됩니다
* `"ok": false`: 작업이 차단됩니다

이 예시는 `Stop` hook을 사용하여 모델에게 모든 요청된 작업이 완료되었는지 물어봅니다:

```json
{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "Check if all tasks are complete. If not, respond with {\"ok\": false, \"reason\": \"what remains to be done\"}."
          }
        ]
      }
    ]
  }
}
```

## 에이전트 기반 Hooks

검증에 파일 검사 또는 명령 실행이 필요한 경우, `type: "agent"` hooks를 사용하세요. 단일 LLM 호출을 하는 프롬프트 hooks와 달리, 에이전트 hooks는 조건을 반환하기 전에 파일을 읽고, 코드를 검색하고, 다른 도구를 사용하여 조건을 검증할 수 있는 서브에이전트를 생성합니다.

에이전트 hooks는 프롬프트 hooks와 동일한 `"ok"` / `"reason"` 응답 형식을 사용하지만, 기본 타임아웃이 60초이고 최대 50번의 도구 사용 턴이 있습니다.

이 예시는 Claude가 중단하도록 허용하기 전에 테스트가 통과하는지 검증합니다:

```json
{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "agent",
            "prompt": "Verify that all unit tests pass. Run the test suite and check the results. $ARGUMENTS",
            "timeout": 120
          }
        ]
      }
    ]
  }
}
```

결정을 내리기 위해 hook 입력 데이터만으로도 충분한 경우 프롬프트 hooks를 사용하세요. 코드베이스의 실제 상태에 대해 무언가를 검증해야 하는 경우 에이전트 hooks를 사용하세요.

## 제한 사항 및 문제 해결

### 제한 사항

* Hooks는 stdout, stderr 및 종료 코드를 통해서만 통신합니다. 슬래시 명령이나 도구 호출을 직접 트리거할 수 없습니다.
* Hook 타임아웃은 기본적으로 10분이며, hook별로 `timeout` 필드로 구성할 수 있습니다 (초 단위).
* `PostToolUse` hooks는 도구가 이미 실행되었으므로 작업을 취소할 수 없습니다.
* `PermissionRequest` hooks는 비대화형 모드(`-p`)에서 발동하지 않습니다. 자동화된 권한 결정에는 `PreToolUse` hooks를 사용하세요.
* `Stop` hooks는 작업 완료 시뿐만 아니라 Claude가 응답을 완료할 때마다 발동합니다.

### Hook이 발동하지 않는 경우

* `/hooks`를 실행하고 hook이 올바른 이벤트 아래에 나타나는지 확인
* 매처 패턴이 도구 이름과 정확히 일치하는지 확인 (매처는 대소문자 구분)
* 올바른 이벤트 유형을 트리거하고 있는지 확인
* 비대화형 모드(`-p`)에서 `PermissionRequest` hooks를 사용하는 경우, `PreToolUse`로 전환하세요

### 출력의 Hook 오류

트랜스크립트에 "PreToolUse hook error: ..."와 같은 메시지가 표시됩니다.

```bash
echo '{"tool_name":"Bash","tool_input":{"command":"ls"}}' | ./my-hook.sh
echo $?  # 종료 코드 확인
```

* "command not found"가 표시되면 스크립트 참조에 절대 경로나 `$CLAUDE_PROJECT_DIR`을 사용하세요
* "jq: command not found"가 표시되면 `jq`를 설치하거나 JSON 파싱에 Python/Node.js를 사용하세요
* 스크립트가 실행되지 않는 경우, 실행 가능하게 만드세요: `chmod +x ./my-hook.sh`

### `/hooks`에 구성된 hooks가 표시되지 않는 경우

* 세션을 재시작하거나 `/hooks`를 열어 다시 로드하세요
* JSON이 유효한지 확인하세요 (후행 쉼표와 주석은 허용되지 않음)
* 설정 파일이 올바른 위치에 있는지 확인하세요

### Stop hook이 계속 실행되는 경우

Stop hook 스크립트는 이미 연속을 트리거했는지 확인해야 합니다. JSON 입력에서 `stop_hook_active` 필드를 파싱하고 `true`이면 조기 종료하세요:

```bash
#!/bin/bash
INPUT=$(cat)
if [ "$(echo "$INPUT" | jq -r '.stop_hook_active')" = "true" ]; then
  exit 0  # Claude가 중단하도록 허용
fi
# ... hook 로직의 나머지 부분
```

### JSON 유효성 검사 실패

Claude Code가 hook을 실행하면 프로필을 소싱하는 셸을 생성합니다 (`~/.zshrc` 또는 `~/.bashrc`). 프로필에 무조건적인 `echo` 문이 포함된 경우, 해당 출력이 hook의 JSON 앞에 추가됩니다. 이를 해결하려면 셸 프로필의 echo 문을 대화형 셸에서만 실행되도록 감싸세요:

```bash
# ~/.zshrc 또는 ~/.bashrc에서
if [[ $- == *i* ]]; then
  echo "Shell ready"
fi
```

### 디버그 기법

`Ctrl+O`로 상세 모드를 전환하여 트랜스크립트에서 hook 출력을 보거나, `claude --debug`로 전체 실행 세부 정보를 확인하세요.

## 더 알아보기

* Hooks 레퍼런스: 전체 이벤트 스키마, JSON 출력 형식, 비동기 hooks, MCP 도구 hooks
* 보안 고려 사항: 공유 또는 프로덕션 환경에서 hooks를 배포하기 전에 검토
* [Bash 명령 유효성 검사기 예시](https://github.com/anthropics/claude-code/blob/main/examples/hooks/bash_command_validator_example.py): 완전한 참조 구현
